import asyncio
import json
from fastapi import APIRouter, HTTPException, status
from dal.userdal import UserDAL
from models.user import User, UserCreate
from redis_om import NotFoundError
from config.redis_conf import redis_stream


router = APIRouter(
    prefix="/users"
)


@router.get('/{primary_key}', response_model=User, status_code=status.HTTP_200_OK)
async def get_user_by_Id(primary_key: str) -> User:
    """ Retrieves the user object given its primary key as an argument

    Args:
        primary_key (str): user's primary key according to the redis model

    Raises:
        HTTPException: 404 error if the user does not exist

    Returns:
        user (User): The user object
    """
    try:
        user = await UserDAL().get_user_by_id(primary_key)
        return user
    except NotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )


@router.get('/', response_model=list[User], status_code=status.HTTP_200_OK)
async def get_all_users(offset: int = 0, limit: int = 50) -> list[User]:
    """ Retrieves all users within the range of the given (or default if not specified)
    limit and offset

    Generates the event "UPDATE_DB" for the stream "user" sending as data the given
    offset & limit, in order to receive the querried list from the corresponding
    micorservices, in order to keep the gateway cache updated

    Args:
        offset (int, optional): amounts of users to skip. Defaults to 0.
        limit (int, optional): maximum amount of users to send. Defaults to 50.

    Returns:
        list[User]: It returns an array of users limited by the offset & limit arguments
    """
    event = {
        'SENDER':'GATEWAY',
        'FLAG':'UPDATE_DB',
        'OFFSET':offset,
        'LIMIT':limit
    }
    user_arr, publishion = await asyncio.gather(
        UserDAL().gat_all_users(offset, limit),
        redis_stream.xadd('user', event)
    )
    return user_arr


@router.post('/', response_model=User, status_code=status.HTTP_201_CREATED)
async def create_user(user: UserCreate) -> User:
    """ This endpoint creates the given user at the gatetway database. The given
    user must not include the fileds PK and STATUS since these are autogenerated
    fields by the system. The user status field will default to "PROCESSING" since
    it requieres validation from other microservices
    
    This endpoint also triggers the event "CREATE" at the stream "user", and
    sends the inserted data through the event. The user status will change to
    "REJECTED" or "ACCEPTED" according to the upcoming events, thus the corresponding
    microservice(s) should have done the requiered validations. If the user creation is
    rejected, it will set an expiration for its entry

    Args:
        user (User): Object corresponding with the user model. SHOULD NOT include
        the field pk since it is autogenerated by the redis model

    Returns:
        User: The created user with all its fields.
    """
    event = {
        'SENDER':'GATEWAY',
        'FLAG':'CREATE',
        'USER':json.dumps(user.dict()),
    }
    await asyncio.gather(
        UserDAL().create_user(user),
        redis_stream.xadd('user', event)   
    )
    return user


@router.delete('/', status_code=status.HTTP_202_ACCEPTED)
async def delete_user(primary_key: str) -> int:
    """ This endpoint changes the user status field to 
    "PROCESSING DELETION".

    This endpoint sends a "DELETE" event on the stream "user"
    and sends as data, the argument primary_key. If the upcomming
    events confirm the deletion, then it will be performed. If
    the upcoming events deny the deletion, the user status field 
    will be changed the state specified by the event(s) involved
    in denying the operation.

    Args:
        primary_key (str): primary of the user to delete

    Returns:
        int:
            1: if the user was found and its deletions is being processed
            0: if such user is not found
    """
    try:
        event = {
            'SENDER':'GATEWAY',
            'FLAG':'DELETE',
            'PRIMARY_KEY': primary_key
        }
        user = await UserDAL().get_user_by_id(primary_key)
        await redis_stream.xadd('user', event)
        user.status = "PROCESSING DELETION"
        await user.save()
        return 1
    except NotFoundError:
        return 0
