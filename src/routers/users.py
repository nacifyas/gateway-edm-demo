import asyncio
import json
from fastapi import APIRouter, HTTPException, status
from dal.userdal import UserDAL
from models.user import User
from redis_om import NotFoundError
from redis_conf import redis


router = APIRouter(
    prefix="/users"
)


@router.get('/{primary_key}', response_model=User, status_code=status.HTTP_200_OK)
async def get_user_by_Id(primary_key: str) -> User:
    """ Retrieves the user object given its primary key as an argument

    Args:
        primary_key (str): user's primary key according to the redis model

    Raises:
        HTTPException: 404 error if user is not found in the entire system

    Returns:
        user (User): The user object
    """
    try:
        user = await UserDAL().get_user_by_id(primary_key)
        return user
    except NotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )


@router.get('/', response_model=list[User], status_code=status.HTTP_200_OK)
async def get_all_users(offset: int = 0, limit: int = 50) -> list[User]:
    """ This endpoint generates an "UPDATE_DB" event, on which it sends the specified
    offset and limit. The events consumer is subscribed to the UPDATE_DB-res channel
    from which it expects to receive all the users, with the applied limit and offset

    Args:
        offset (int, optional): amounts of users to skip. Defaults to 0.
        limit (int, optional): maximum amount of users to send. Defaults to 50.

    Returns:
        list[User]: It returns an array of users limited by the offset & limit arguments
    """
    user_arr, publishion = await asyncio.gather(
        UserDAL().gat_all_users(offset, limit),
        redis.publish("user:UPDATE_DB", f"{offset}:{limit}")
    )
    return user_arr


@router.post('/', response_model=User, status_code=status.HTTP_201_CREATED)
async def create_user(user: User) -> User:
    """ This endpoint generates a "user:CREATE" event. When a new user is created into
    the system, in order to mitigate the delays due to database validation and networks
    hops betweem microservices to store the user, a provisional copy of the user is
    stored in the gateway database (or cache), and its data is sent through the event.
    This microservice is subscribed to the channel user:CREATE-res from which expects
    the approval to keep or invalidate the created at this microservice.

    Args:
        user (User): Object corresponding with the user model. SHOULD NOT include
        the field pk since it is autogenerated by the redis model

    Returns:
        User: The created user with all its fields.
    """
    await asyncio.gather(
        UserDAL().create_user(user),
        redis.publish("user:CREATE", json.dumps(user.dict())),
    )
    return user


@router.put('/', response_model=User, status_code=status.HTTP_202_ACCEPTED)
async def update_user(user: User) -> User:
    """This endpoint is similar the POST endpoint of this API. It also
    generates a user:CREATE event in which it sends the input data.
    It expects an approval or a denial event for validation, from 
    the channel user:UPDATE-res

    Args:
        user (User): Existing user with mofied fields

    Returns:
        User: The input user
    """
    await asyncio.gather(
        redis.publish("user:UPDATE", json.dumps(user.dict())),
        UserDAL().update_user(user)
    )
    return user


@router.delete('/', status_code=status.HTTP_202_ACCEPTED)
async def delete_user(primary_key: str) -> int:
    """ Porceeds with the deletion of the user carrying
    the specified primary key. This endpoint generates 
    an event to synchronize this deletion with the 
    microservices that may requiere it, through the channel
    user:DELETE providing as a message the primary_key.
    This microservice is subscribed to the event user:DELETION-res
    from which it could receive a denial to delete the user. 
    No data is actually deleted until there is approval from the
    the user:DELETION-res channel

    Args:
        primary_key (str): primary of the user to delete

    Returns:
        int:
            1: if deletion was successful
            0: if no deletion was done
    """
    deletion, publishion = await asyncio.gather(
        UserDAL().delete_user(primary_key),
        redis.publish("user:DELETE", primary_key)
    )
    return deletion


